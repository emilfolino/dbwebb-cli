#!/bin/bash
# dbwebb-validate: tool to validate and publish course repos
#
# The MIT License (MIT)
#
# Copyright (c) 2014-2015 Mikael Roos (mos@dbwebb.se)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
DBW_VERSION="1.1.1"
function usage ()
{
    local txt=(
"Usage: dbwebb-validate [options] [item]"
""
"Item:"
"  Any of the exercises for a course, example:"
"  - kmom01, kmom02, ..., kmom10"
"  - me, tutorial, example"
"  or relative path,"
"  or absolute path"
""
"Options:"
"  -c, --check    Check installed tools."
"  -p, --publish  Publish it."
"  -h, --help     Print help."
"  -v, --version  Print version."
""
"Manual at: http://dbwebb.se/dbwebb-cli"
    )
    printf "%s\n" "${txt[@]}"
}



function version ()
{
    local txt=(
"dbwebb-validate version $DBW_VERSION"
    )
    printf "%s\n" "${txt[@]}"
}



function badUsage ()
{
    local message="$1"
    local txt=(
"For an overview of the command, execute:"
"dbwebb-validate --help"
    )
    
    if [ ! -z "$message" ]; then
        printf "$message\n"
    fi
    
    printf "%s\n" "${txt[@]}"
}
# --------------- DBWEBB FUNCTIONS PHASE START ---------------

#
# Create the config file .dbwebb.config.
#
function createConfig()
{
    local first=$1
    local noInput=$2
    local acronym
    local remoteHost

    if [ -z $first ]
    then

        printf "The config-file '$DBW_CONFIG_FILE_NAME' will now be created in your home directory: '$HOME'"

    elif [ $first = "update" ]
    then

        printf "Your config file will be automatically updated. Then re-run your command.\n"

    elif [ $first = "upgrade" ]
    then

        printf "Your config file will be automatically updated."

    elif [ $first = "create" ]
    then

        printf "I will now re-create the configuration file '$DBW_CONFIG_FILE_NAME' in your home directory: '$HOME'."

    fi


    if [[ ! $noInput ]]; then
        DBW_USER=${DBW_USER:-$USER}
        printf "\nWhat is your student acronym? [$DBW_USER] "
        read acronym
    fi

    acronym=${acronym:-$DBW_USER}
    remoteHost=${remoteHost:-ssh.student.bth.se}

    echo "DBW_USER='$acronym'"         > "$DBW_CONFIG_FILE"
    echo "DBW_HOST='$remoteHost'"     >> "$DBW_CONFIG_FILE"

    printf "$MSG_OK The config file '$DBW_CONFIG_FILE' is now up-to-date.\n"
}



#
# Check for installed commands
#
function checkCommand()
{
    local COMMAND="$1"

    if ! hash "$COMMAND" 2>/dev/null; then
        printf "Command $COMMAND not found."
    else 
        printf "$( which $COMMAND )"
    fi
}



#
# Execute a command in a controlled manner
#
function wget {
  if command wget -h &>/dev/null
  then
    command wget "$@"
  else
    set "${*: -1}"
    lynx -source "$1" > "${1##*/}"
  fi
}



#
# Execute a command in a controlled manner
#
executeCommand()
{
    INTRO="$1"

    if [ $SKIP_READLINE = "no" ]
    then
        printf "$INTRO"
        printf "\nPress enter/return to continue..."
        read void
    fi

    REALLY="$4"
    if [ ! -z $REALLY ]
    then
        printf "\nAre you really sure? [yN] "
        read answer
        default="n"
        answer=${answer:-$default}

        if [ ! \( "$answer" = "y" -o "$answer" = "Y" \) ]
        then
            printf "Exiting...\n"
            exit 0
        fi
    fi

    COMMAND=$2

    if [ $VERY_VERBOSE = "yes" ]
    then
        printf "\nExecuting command:"
        printf "\n$COMMAND"
        printf "\n-----------------------------------------"
        printf "\n"
    fi

    bash -c "$COMMAND"
    STATUS=$?

    if [ $VERY_VERBOSE = "yes" ]
    then
        printf "\n-----------------------------------------"
    fi

    MESSAGE=$3
    if [ $STATUS = 0 ]
    then
        printf "\n$MSG_OK $MESSAGE"
    else
        printf "\n$MSG_FAILED $MESSAGE"
    fi
    printf "\n"
    printf "\n"

    return $STATUS
}



#
# Check if within a valid course repo or exit
#
function checkIfValidCourseRepoOrExit()
{
    if [ "$DBW_COURSE_REPO_VALID" != "yes" ]; then
        printf "$MSG_FAILED Could not find file '$DBW_COURSE_FILE_NAME', this is not a valid course repo."
        printf "\nThis command must be executed within a valid course repo."
        printf "\n"
        exit 1
    fi
}



#
# Set proper rights for files and directories
#
setChmod()
{
    if [ $VERY_VERBOSE = "yes" ]; then
        printf "\nEnsuring that all files and directories are readable for all, below $DBW_COURSE_DIR."
    fi

    $FIND "$DBW_COURSE_DIR" -type d -exec chmod u+rwx,go+rx {} \;  
    $FIND "$DBW_COURSE_DIR" -type f -exec chmod u+rw,go+r {} \;   
}



#
# Convert course specific module to path on disk
#
mapCmdToDir()
{
    local CMD="$1"
    local RES=""

    if [ -z "$CMD" ]; then 
        return
    fi 

    case "$CMD" in
        example)    RES="example" ;;
        tutorial)   RES="tutorial" ;;
        me)         RES="me" ;;
        kmom01)     RES="me/kmom01" ;;
        kmom02)     RES="me/kmom02" ;;
        kmom03)     RES="me/kmom03" ;;
        kmom04)     RES="me/kmom04" ;;
        kmom05)     RES="me/kmom05" ;;
        kmom06)     RES="me/kmom06" ;;
        kmom10)     RES="me/kmom10" ;;
    esac

    if [ ! -z $RES ]; then 
        printf "$RES"
        return
    fi 

    case "$DBW_COURSE" in
        htmlphp)
            case "$CMD" in
                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom05/lab4" ;;
                lab5)       RES="me/kmom06/lab5" ;;
            esac
            ;;

        python)
            case "$CMD" in
                hello)      RES="me/kmom01/hello" ;;
                plane)      RES="me/kmom01/plane" ;;

                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom05/lab4" ;;
                lab5)       RES="me/kmom06/lab5" ;;
                lab6)       RES="me/kmom06/lab6" ;;

                marvin1)    RES="me/kmom02/marvin1" ;;
                marvin2)    RES="me/kmom03/marvin2" ;;
                marvin3)    RES="me/kmom04/marvin3" ;;
                marvin4)    RES="me/kmom05/marvin4" ;;
                marvin5)    RES="me/kmom06/marvin5" ;;

                game1)      RES="me/kmom04/game1" ;;
                game2)      RES="me/kmom05/game2" ;;
                game3)      RES="me/kmom06/game3" ;;

                adventure)  RES="me/kmom10/adventure" ;;
            esac
            ;;

        javascript1)
            case "$CMD" in
                sandbox)      RES="me/kmom01/sandbox" ;;
                hangman)      RES="me/kmom06/hangman" ;;
                intelligence) RES="me/kmom10/intelligence" ;;

                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom04/lab4" ;;
                lab5)       RES="me/kmom05/lab5" ;;

                flag1)      RES="me/kmom02/flag1" ;;
                flag2)      RES="me/kmom03/flag2" ;;
                flag3)      RES="me/kmom04/flag3" ;;
                flag4)      RES="me/kmom05/flag4" ;;
                flag5)      RES="me/kmom06/flag5" ;;

                baddie1)    RES="me/kmom02/baddie1" ;;
                baddie2)    RES="me/kmom03/baddie2" ;;
                baddie3)    RES="me/kmom04/baddie3" ;;
                #baddie4)    RES="me/kmom05/baddie4" ;;
                #baddie5)    RES="me/kmom06/baddie5" ;;
            esac
            ;;

        linux)
            case "$CMD" in
                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom05/lab4" ;;
                lab5)       RES="me/kmom06/lab5" ;;
            esac
            ;;

        webapp)
            case "$CMD" in
                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom05/lab4" ;;
                lab5)       RES="me/kmom06/lab5" ;;
            esac
            ;;
    esac

    printf "$RES"
    return
}



#
# Get path to dir to check, use both parts of courses and fallback
# to absolute and relative paths.
#
function getPathToDirectoryFor()
{
    local dir="$( mapCmdToDir $1 )" 
    
    if [ -z "$command" ]; then
        echo "$DBW_CURRENT_DIR"
    elif [ -z "$dir" -a -d "$command" ]; then
        echo "$command"
    elif [ -z "$dir" -a -d "$DBW_CURRENT_DIR/$command" ]; then
        echo "$DBW_CURRENT_DIR/$command"
    elif [ -d "$DBW_COURSE_DIR" -a -d "$DBW_COURSE_DIR/$dir" ]; then
        echo "$DBW_COURSE_DIR/$dir"
    else 
        printf "\n$MSG_FAILED The item '$command' was mapped to directory '$dir' which is not a valid directory."
        printf "\n"
        exit 1
    fi
}



#
# Validate the uploaded files
#
createUploadDownloadPaths()
{
    SUBDIR="$( mapCmdToDir $ITEM )"

    if [ -z "$WHAT" -o -z "$WHERE" ]; then
        printf "$MSG_FAILED Missing argument for source or destination. Perhaps re-create the config-file?"
        printf "\n\n"
        exit 1
    fi

    if [ ! -z "$ITEM" -a -z "$SUBDIR" ]; then
        printf "\n$MSG_FAILED Not a valid combination  course: '$DBW_COURSE' and item: '$ITEM'."
        printf "\n\n"
        exit 1
    fi

    if [ ! -z "$SUBDIR" ]; then
        WHAT="$WHAT/$SUBDIR/"
        WHERE="$WHERE/$SUBDIR/"
    else
        WHAT="$WHAT/"
        WHERE="$WHERE/"
    fi

    if [ ! -d "$WHAT" ]; then
        printf "\n$MSG_FAILED Target directory is not a valid directory: '$WHAT'"
        printf "\n\n"
        exit 1
    fi
}



#
# Validate and Publish the uploaded files
#
publishResults()
{
    WHAT="$1"
    WHERE="$2"
    ITEM="$3"
    SUBDIR=""

    createUploadDownloadPaths

    local LOG="$HOME/.dbwebb-publish.log"
    local INTRO="I will now try to init the remote server and create a directory where all uploaded files will reside."
    local COMMAND1="$RSYNC_CMD '$WHAT' '$WHERE'"
    local COMMAND2="$SSH_CMD 'cd $DBW_BASEDIR/$DBW_COURSE; dbwebb-validate $IGNORE_FAULTS $WHAT' | tee '$LOG';"
    local MESSAGE="to validate and publish all course results. Saved a log of the output, review it as:\nless -R $LOG"
    executeCommand "$INTRO" "$COMMAND1; $COMMAND2" "$MESSAGE"

    if [ $? -eq 0 ]
    then
        printf "Your files are now"
    else
        printf "Some of your files might be"
    fi
    printf " published on $DBW_BASEURL"
    printf "\n"
}



#
# Inspect uploaded files
#
inspectResults()
{
    WHAT=$1
    WHO=$2
    INTRO="I will now inspect the choosen kmom for the choosen user, if you have privilegies to do that."
    LOG="$HOME/.dbwebb-inspect.log"
    COMMAND="$SSH_CMD 'cd $DBW_BASEDIR/$DBW_COURSE; bin/dbwebb-inspect $WHAT $WHO' | tee '$LOG'; "
    MESSAGE="to inspect the course results. Saved a log of the output, review it as:\nless -R '$LOG'"

    #COMMAND="$SSH_CMD 'cd $DBW_BASEDIR/$DBW_COURSE; bin/dbwebb-inspect $WHAT $WHO'"
    #MESSAGE="to inspect the course results."

    #if [ "$USER" = "$WHO" ]
    #then
        #upload="$UPLOAD"
    #else
        #upload="$UPLOAD_MINIMAL"
    #fi

    #executeCommand "$INTRO" "$upload; $COMMAND" "$MESSAGE"
    executeCommand "$INTRO" "$COMMAND" "$MESSAGE"
}



# --------------------- To be validated -------------------------------


#
# Create a lab
#
createLab()
{
    LAB="$1"
    INTRO="Create laboration $LAB."
    COMMAND="bin/dbwebb-create \"$LAB\""
    MESSAGE="to create the lab."
    executeCommand "$INTRO" "$COMMAND" "$MESSAGE"
}




# -----------------------PERHAPS USE THES LATER ON BUT NOT FOR NOW -----------------------

#
# Upload results to the server
#
uploadToServer()
{
    subdir=${DBW_CURRENT_DIR#"$DBW_COURSE_DIR/"}

    INTRO="Your current working directory '$DBW_CURRENT_DIR' will now be uploaded to remote server."
    COMMAND="$RSYNC_CMD '$DBW_CURRENT_DIR/' '$DBW_REMOTE_DESTINATION/$subdir/'"
    MESSAGE="to upload files."
    executeCommand "$INTRO" "$COMMAND" "$MESSAGE"
}



#
# Download from the server
#
downloadFromServer()
{
    subdir=${DBW_CURRENT_DIR#"$DBW_COURSE_DIR/"}

    INTRO="WARNING: Downloading remote '$DBW_REMOTE_DESTINATION/$subdir/\n         to the current working directory '$DBW_CURRENT_DIR/'.\nWARNING: Local files MAY BE overwritten."
    COMMAND="$RSYNC_CMD '$DBW_REMOTE_DESTINATION/$subdir/' '$DBW_CURRENT_DIR/'"
    MESSAGE="to download files."
    executeCommand "$INTRO" "$COMMAND" "$MESSAGE" "REALLY?"
}


#------------------------- HERE ARE THE MAIN COMMANDS -------------------------------


#
# Create default files.
#
function dbwebb-init-me()
{
    local meDefault="$DBW_COURSE_DIR/.default/"
    local me="$DBW_COURSE_DIR/me/"

    local intro="Initiating the directory 'me/' by copying directory structure and files from the directory '.default/' (will not overwrite existing files)."
    local command="$RSYNC -av --exclude README.md --ignore-existing \"$meDefault\" \"$me\""
    local message="to init the directory 'me/'."

    checkIfValidCourseRepoOrExit
    executeCommand "$intro" "$command" "$message"
}



#
# Init directory structure at the server.
#
function dbwebb-init-server()
{    
    local intro="Intiating the remote server '$DBW_HOST' by connecting as '$DBW_USER' and creating directories (if needed) where all uploaded files will reside."
    # TODO Should use DBW_BASEDIR 
    local command="$SSH_CMD 'sh -c \"if [ ! -d dbwebb-kurser ]; then mkdir dbwebb-kurser; fi; chmod 700 dbwebb-kurser; echo; echo \"dbwebb-kurser:\"; ls -l dbwebb-kurser; if [ ! -d www/dbwebb-kurser ]; then mkdir www/dbwebb-kurser; fi; chmod 755 www/dbwebb-kurser; echo; echo \"www/dbwebb-kurser:\"; ls -l www/dbwebb-kurser\"'"
    local message="to init the server."

    checkIfValidCourseRepoOrExit
    executeCommand "$intro" "$command" "$message"
}



#
# Create and use ssh-keys to login.
#
function dbwebb-sshkey()
{
    local sshkey="$HOME/.ssh/dbwebb"

    if [ ! -d "$HOME/.ssh" ]
    then
        mkdir "$HOME/.ssh"
    fi

    local intro="First we need to create a ssh key and store it locally."
    local command="ssh-keygen -t dsa -f '$sshkey' -N ''"
    local message="to create the ssh key."
    executeCommand "$intro" "$command" "$message"

    # Bug (?) om Cygwin & win 8
    # TODO refactor 
    if [ $IS_CYGWIN = "yes" ]
    then
        chgrp -vR "$CYGWIN_DEFAULT_GROUP" "$HOME/.ssh"
    fi

    chmod 700 "$HOME/.ssh"
    chmod 600 "$sshkey" "$sshkey.pub"

    intro="I will now install the ssh-key at the remote server."
    command="cat '$sshkey.pub' | ssh $DBW_USER@$DBW_HOST 'sh -c \"if [ ! -d .ssh ]; then mkdir .ssh; fi; chmod 700 .ssh; touch .ssh/authorized_keys; cat >> .ssh/authorized_keys\"'"
    message="to install the ssh-keys."    
    executeCommand "$intro" "$command" "$message"
}



#
# Login to the server
#
function dbwebb-login()
{
    local intro="I will now login to the server '$DBW_HOST' as '$DBW_USER' using ssh-keys if available."
    local command="$SSH_CMD"
    local message="to establish the connection."
    
    executeCommand "$intro" "$command" "$message"
}



#
# Update course repo to latest version
#
function dbwebb-update()
{
    local intro="Update course-repo with latest changes from its master at GitHub."
    local command="$GIT pull"
    local message="to update course repo."
    
    checkIfValidCourseRepoOrExit
    executeCommand "$intro" "$command" "$message"
}



#
# Display information on the environment
#
function dbwebb-check()
{
    printf "Details on installed utilities."
    printf "\n------------------------------------"
    printf "\nbash:                  %s" "$( checkCommand $BASH )"
    printf "\ngit:                   %s" "$( checkCommand $GIT )"
    printf "\nssh:                   %s" "$( checkCommand $SSH )"
    printf "\nrsync:                 %s" "$( checkCommand $RSYNC )"
    printf "\nwget:                  %s" "$( checkCommand $WGET )"
    printf "\ncurl:                  %s" "$( checkCommand $CURL )"
    printf "\n"

    printf "\nDetails on the dbwebb-environment."
    printf "\n------------------------------------"
    printf "\nOperatingsystem:       $DBW_OS"
    printf "\nCommand issued:        $DBW_EXECUTABLE"
    printf "\nVersion of dbwebb is:  $DBW_VERSION"
    printf "\nPath to executable:    '$DBW_EXECUTABLE_DIR'"
    printf "\nConfig-file:           '$DBW_CONFIG_FILE'"
    printf "\nWorking directory:     '$DBW_CURRENT_DIR'"
    printf "\nLocal user:            '$USER'"
    printf "\nLocal homedir:         '$HOME'"
    printf "\nRemote user:           '$DBW_USER'"
    printf "\nRemote host:           '$DBW_HOST'"
    printf "\n"

    printf "\nDetails on current course-repo."
    printf "\n------------------------------------"

    if [ "$DBW_COURSE_REPO_VALID" = "yes" ]; then
        printf "\nCurrent course-repo:   '$DBW_COURSE'"
        printf "\nCourse directory:      '$DBW_COURSE_DIR'"
        printf "\nCourse-repo version:   $( $GIT describe --always )"
        printf "\n\nLatest update to course repo was:"
        printf "\n"
        $GIT log -1
    else 
        printf "\nThis is not a valid course repo."
    fi
    printf "\n"
    printf "\n"
}



#
# Create or re-create the config file.
#
function dbwebb-config()
{
    createConfig
}



#
# Push/upload results to the server
#
function dbwebb-upload()
{
    #pushToServer "" "$" "$2"
    
    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_DESTINATION"
    ITEM="$1"
    SUBDIR=""

    checkIfValidCourseRepoOrExit
    createUploadDownloadPaths
    setChmod

    local intro="Uploading the directory '$WHAT' to '$WHERE'."
    local command="$RSYNC_CMD '$WHAT' '$WHERE'"
    local message="to upload data."
    executeCommand "$intro" "$command" "$message"
}



#
# Pull/download from the server
#
function dbwebb-download()
{
    #pullFromServer "$DBW_COURSE_DIR" "$DBW_REMOTE_DESTINATION" "$2"
    
    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_DESTINATION"
    ITEM="$1"
    SUBDIR=""

    checkIfValidCourseRepoOrExit
    createUploadDownloadPaths

    local intro="Downloading the directory '$WHERE' to '$WHAT'.\nExisting local files that are newer will not be overwritten."
    local command="$RSYNC_DOWNLOAD_CMD '$WHERE' '$WHAT'"
    local message="to download data."
    executeCommand "$intro" "$command" "$message" "really?"
}



#
# Validate the uploaded files
#
function dbwebb-validate()
{
    WHAT="$1"
    WHERE="$2"
    ITEM="$3"
    SUBDIR=""

    createUploadDownloadPaths
    setChmod

    local LOG="$HOME/.dbwebb-validate.log"
    local INTRO="I will now upload files to the remote server and validate them."
    local COMMAND1="$RSYNC_CMD '$WHAT' '$WHERE'"
    local COMMAND2="$SSH_CMD 'cd $DBW_BASEDIR/$DBW_COURSE; dbwebb-validate -n $IGNORE_FAULTS $WHAT' | tee '$LOG';"
    local MESSAGE="to validate course results. Saved a log of the output, review it as:\nless -R '$LOG'"
    executeCommand "$INTRO" "$COMMAND1; $COMMAND2" "$MESSAGE"
}



#
# Selfupdate
#
dbwebb-selfupdate()
{
    local INTRO="Selfupdating dbwebb-cli from https://github.com/mosbth/dbwebb-cli."
    local COMMAND="wget https://raw.githubusercontent.com/mosbth/dbwebb-cli/master/dbwebb2 -O /tmp/$$; install /tmp/$$ /usr/local/bin/dbwebb; rm /tmp/$$"
    local MESSAGE="to update dbwebb installation."
    executeCommand "$INTRO" "$COMMAND" "$MESSAGE"
}



# --------------- DBWEBB FUNCTIONS PHASE END ---------------
# --------------- DBWEBB BOOTSTRAP PHASE START ---------------

#
# Specify the utilities used
#
ECHO="printf"
GIT="git"
RSYNC="rsync"
SSH="ssh"
SED="sed"
WGET="wget"
CURL="curl"
BASH="bash"
FIND="find"


# Revise these
UPLOAD="$RSYNC -av --delete --exclude literature --exclude .git -e \"ssh $DBW_SSH_KEY_OPTION\" \"$SOURCE\" \"$DESTINATION\""
UPLOAD_MINIMAL="$RSYNC -av --delete --exclude me --exclude tutorial --exclude example --exclude literature --exclude .git -e \"ssh $DBW_SSH_KEY_OPTION\" \"$SOURCE\" \"$DESTINATION\""


# Settins
MSG_OK="\033[0;30;42mOK\033[0m"
MSG_WARNING="\033[43mWARNING\033[0m"
MSG_FAILED="\033[0;37;41mFAILED\033[0m"


# For asserts
ASSERTS=0
FAULTS=0
TMPFILE="/tmp/dbwebb-error-{$USER}-$$"



#
# Find my environment, before any work can be done
#


# What was the command issued?
DBW_EXECUTABLE="$( basename "$0" )"

# Where is the executable
DBW_EXECUTABLE_DIR="$( dirname "$0" )"

# Where is the installation directory
#DBW_CLIDIR="dbwebb-cli"
#DBW_VERSION_FILE_NAME=".dbwebb.version"

#if [ -f "$DBW_EXECUTABLE_DIR/$DBW_VERSION_FILE_NAME" ]; then
#    DBW_INSTALL_DIR="$DBW_EXECUTABLE_DIR"
#elif [ -d "$DBWEBB_HOME" -a -d "$DBWEBB_HOME/$DBW_CLIDIR" ]; then
#    DBW_INSTALL_DIR="$DBWEBB_HOME/$DBW_CLIDIR"
#elif [ -d "$DBWEBB_CLI_HOME" ]; then
#    DBW_INSTALL_DIR="$DBWEBB_CLI_HOME"
#elif [ -d "$HOME/$DBW_BASEDIR/$DBW_CLIDIR" ]; then
#    DBW_INSTALL_DIR="$HOME/$DBW_BASEDIR/$DBW_CLIDIR"
#else 
#    $ECHO "$MSG_FAILED Could not determine the installation directory. I tried tried the environment variables \$DBWEBB_HOME and \$DBWEBB_CLI_HOME and looked in \$HOME/$DBW_BASEDIR/$DBW_CLIDIR.\n"
#    exit 1
#fi



# Get the current version installed as $DBW_VERSION
#DBW_VERSION_FILE="$DBW_INSTALL_DIR/$DBW_VERSION_FILE_NAME"
#if [ ! -f "$DBW_VERSION_FILE" ]; then
#    $ECHO "$MSG_FAILED Missing file $DBW_VERSION_FILE_NAME. The installation directory does not contain a valid installation.\n"
#    exit 1
#fi
#source "$DBW_VERSION_FILE"



# What is the current directory
DBW_CURRENT_DIR="$( pwd )"



# What is the directory of the current course repo, find recursivly up the tree
DBW_COURSE_FILE_NAME=".dbwebb.course"

dir="$DBW_CURRENT_DIR/."
while [ "$dir" != "/" ]; do 
    dir=$( dirname "$dir" )
    found="$( find "$dir" -maxdepth 1 -name $DBW_COURSE_FILE_NAME )"
    if [ "$found" ]; then 
        DBW_COURSE_DIR="$( dirname "$found" )"
        break
    fi
done



# Where is the directory for the course repos, if any
#DBW_BASEDIR="dbwebb-kurser"
#if [ -d "$DBWEBB_HOME" ]; then
#    DBW_HOME="$DBW_BASEDIR"
#elif [ -d "$HOME/$DBW_BASEDIR" ]; then
#    DBW_HOME="$HOME/$DBW_BASEDIR"
#fi



# Get the name of the course as $DBW_COURSE
DBW_COURSE_FILE="$DBW_COURSE_DIR/$DBW_COURSE_FILE_NAME"
DBW_COURSE_REPO_VALID=""
if [ -f "$DBW_COURSE_FILE" ]; then
    DBW_COURSE_REPO_VALID="yes"
    source "$DBW_COURSE_FILE"
fi



# Where is the .dbwebb.config-file
DBW_CONFIG_DEFAULT_FILE="$DBW_INSTALL_DIR/dbwebb2-config-sample"
DBW_CONFIG_FILE_NAME=".dbwebb.config"
DBW_CONFIG_FILE="$HOME/$DBW_CONFIG_FILE_NAME"
if [ ! -f "$DBW_CONFIG_FILE" ]; then

    # If the command is to init-repo, then execute that and create a config-file
    if [ "$1" = "init-repo" ]; then
        createConfig
        exit 0
    fi
else
    source "$DBW_CONFIG_FILE"
fi

# Check OS
DBW_OS="$( uname -a )"

# Create the ssh-command with details from the config-file
SSH_CMD="$SSH ${DBW_USER}@${DBW_HOST} $DBW_SSH_KEY_OPTION"

# Create the basis for the upload command
RSYNC_CMD="$RSYNC -av --delete --exclude .git --exclude .gitignore -e \"ssh $DBW_SSH_KEY_OPTION\""
RSYNC_DOWNLOAD_CMD="$RSYNC -avu -e \"ssh $DBW_SSH_KEY_OPTION\""

DBW_REMOTE_DESTINATION="${DBW_USER}@${DBW_HOST}:$DBW_BASEDIR/$DBW_COURSE"



# --------------- DBWEBB BOOTSTRAP PHASE END ---------------
# --------------- DBWEBB-VALIDATE MAIN START HERE ---------------
#
# External tools
#
HTMLHINT="dbwebb-htmlhint"
CSSHINT="htmlhint"
JSHINT="jshint"
JSCS="jscs"

HTML_MINIFIER="html-minifier"

CLEANCSS="cleancss"
CLEANCSS_OPTIONS="--s1 --skip-import"

UGLIFYJS="uglifyjs"
UGLIFYJS_OPTIONS="--mangle --compress --screw-ie8 --comments"

PYLINT="pylint"
PYLINT_OPTIONS="-r n"

PHP="php"
PHPMD="phpmd"
PHPCS="phpcs"
PHPUGLIFY=""

CHECKBASH="shellcheck --shell=bash"
CHECKSH="shellcheck --shell=sh"

if [[ $DBW_COURSE_DIR ]]; then
    HTML_MINIFIER_CONFIG="--config-file '$DBW_COURSE_DIR/.html-minifier.conf'"
    PYLINT_CONFIG="--rcfile $DBW_COURSE_DIR/.pylintrc"
fi



#
# Check for installed tools
#
function checkInstalledValidateTools
{
    printf "Check for installed validation tools.\n"
    printf " htmlhint:      %s\n" "$( checkCommand $HTMLHINT )"
    printf " csshint:       %s\n" "$( checkCommand $CSSHINT )"
    printf " jshint:        %s\n" "$( checkCommand $JSHINT )"
    printf " jscs:          %s\n" "$( checkCommand $JSCS )"
    printf " pylint:        %s\n" "$( checkCommand $PYLINT )"
    printf " php:           %s\n" "$( checkCommand $PHP )"
    printf " phpmd:         %s\n" "$( checkCommand $PHPMD )"
    printf " phpcs:         %s\n" "$( checkCommand $PHPCS )"
    printf " bash:          %s\n" "$( checkCommand $CHECKBASH )"
    printf " sh:            %s\n" "$( checkCommand $CHECKSH )"

    printf "Check for installed publishing tools.\n"
    printf " html-minifier: %s\n" "$( checkCommand $HTML_MINIFIER )"
    printf " cleancss:      %s\n" "$( checkCommand $CLEANCSS )"
    printf " uglifyjs:      %s\n" "$( checkCommand $UGLIFYJS )"
    printf " phpuglify:     %s\n" "$( checkCommand $PHPUGLIFY )"
}



#
# Perform an assert
#
function assert()
{
    EXPECTED=$1
    TEST=$2
    MESSAGE=$3
    ASSERTS=$(( $ASSERTS + 1 ))

    sh -c "$TEST" > "$TMPFILE" 2>&1
    STATUS=$?
    ERROR=$(cat $TMPFILE)

    if [ \( ! $STATUS -eq $EXPECTED \) -o \( ! -z "$ERROR" \) ]; then
        FAULTS=$(( $FAULTS + 1 ))

        printf "\n\n$MSG_WARNING $MESSAGE\n" 
        [ -z "$ERROR" ] || printf "$ERROR\n\n"
    fi

    return $STATUS
}



#
# Clean up and output results from asserts
#
function assertResults()
{
    rm -f "$TMPFILE"
    
    if [ $FAULTS -gt 0 ]
        then
        printf "\n\n$MSG_FAILED"
        printf " Asserts: $ASSERTS Faults: $FAULTS\n\n"
        exit 1
    fi
    
    printf "\n$MSG_OK"
    printf " Asserts: $ASSERTS Faults: $FAULTS\n"
    exit 0
}



#
# Perform validation tests
#
function validateHtmlCssJs()
{
    local dir="$1"

    printf "\n *.html using HTMLHint."
    for filename in $(find "$dir/" -type f -name '*.html'); do
        assert 0 "$HTMLHINT $filename" "HTMLHINT failed: $filename"
    done

    printf "\n *.css using CSSHint."
    for filename in $(find "$dir/" -type f -name '*.css'); do
        printf ""
        #assert 0 "$CSSHINT $filename" "CSSHint failed: $filename"
    done

    printf "\n *.js using JSHint."
    for filename in $(find "$dir/" -type f -name '*.js'); do
        assert 0 "$JSHINT $filename" "JSHint failed: $filename"
    done

    printf "\n *.js using JSCS."
    for filename in $(find "$dir/" -type f -name '*.js'); do
        printf ""
        #assert 0 "$JSCS $filename" "JSCS failed: $filename"
    done
}



#
# Perform validation tests
#
function validatePHP()
{
    local dir="$1"

    printf "\n *.php using PHP."
    for filename in $(find "$dir/" -type f -name '*.html'); do
        printf ""
        #assert 0 "$PHP $filename" "PHP failed: $filename"
    done

    printf "\n *.php using PHPMD."
    for filename in $(find "$dir/" -type f -name '*.css'); do
        printf ""
        #assert 0 "$PHPMD $filename" "PHPMD failed: $filename"
    done

    printf "\n *.php using PHPCS."
    for filename in $(find "$dir/" -type f -name '*.css'); do
        printf ""
        #assert 0 "$PHPCS $filename" "PHPCS failed: $filename"
    done
}



#
# Perform validation tests
#
function validateShell()
{
    local dir="$1"

    printf "\n *.bash using ShellCheck."
    for filename in $(find "$dir/" -type f -name '*.bash'); do
        printf ""
        #assert 0 "$SHELLCHECK $filename" "ShellCheck failed: $filename"
    done

    printf "\n *.sh using ShellCheck."
    for filename in $(find "$dir/" -type f -name '*.sh'); do
        printf ""
        #assert 0 "$SHELLCHECK $filename" "ShellCheck failed: $filename"
    done
}



#
# Perform validation tests
#
function validatePython()
{
    local dir="$1"

    printf "\n *.py using Pylint."
    for filename in $(find "$dir/" -type f -name '*.py'); do
        assert 0 "$PYLINT $PYLINT_OPTIONS $PYLINT_CONFIG $filename" "pylint failed: $filename"
    done

    printf "\n *.cgi using Pylint."
    for filename in $(find "$dir/" -type f -name '*.cgi'); do
        assert 0 "$PYLINT $PYLINT_OPTIONS $PYLINT_CONFIG $filename" "pylint failed: $filename"
    done
}



#
# Set correct mode on published file and dirs
#
publishChmod()
{
    local dir="$1"

    if [ -d "$dir" ]; then
        find "$dir" -type d -exec chmod a+rx {} \;  
        find "$dir" -type f -exec chmod a+r {} \;   
        find "$dir" -type f -name '*.py' -exec chmod go-r {} \;
    fi
}



# ----------------------------------------- TO BE VALIDATED --------------------


#
# Publish all
#
publish()
{
    local from="$1"
    local to="$2"
 
    if [ ! -d "$from" ]; then
        printf "$MSG_FAILED Publish without valid from directory: '$from'\n"
        exit 2
    elif [ -z "$to" ]; then
        printf "$MSG_FAILED Publish with empty target directory: '$to'\n"
        exit 2
    fi
 
    printf "rsync -a --delete %s %s" "$from/" "$to/"
    return
    
    printf " minify *.html"
    for filename in $(find "$to/" -type f -name '*.html'); do
        assert 0 "$HTML_MINIFIER $HTML_MINIFIER_OPTIONS $filename --output $filename" "HTMLMinifier failed: $filename"
    done

    printf ", minify *.css"
    for filename in $(find "$to/" -type f -name '*.css'); do
        assert 0 "$CLEANCSS $filename -o $filename" "CleanCSS failed: $filename"
    done

    printf ", uglify *.js"
    for filename in $(find "$to/" -type f -name '*.js'); do
        assert 0 "$UGLIFYJS $filename -o $filename $UGLIFYJS_OPTIONS" "UglifyJS failed: $filename"
    done
    
    printf ", uglify *.php"
    for filename in $(find "$to/" -type f -name '*.js'); do
        printf ""
        #assert 0 "$UGLIFYJS $filename -o $filename $UGLIFYJS_OPTIONS" "UglifyJS failed: $filename"
    done
    
    printf ", chmod"
    publishChmod "$dir/"
    printf ". Done"
}



#
# Process options
#
while (( $# ))
do
    case "$1" in
        
        --check | -c)
            checkInstalledValidateTools
            exit 0
            ;;

        --publish | -p)
            optPublish="yes"
            shift
            ;;

        --help | -h)
            usage
            exit 0
        ;;
        
        --version | -v)
            version
            exit 0
        ;;
                
        *)
            if [[ $command ]]; then
                badUsage "$MSG_FAILED Too many options/items and/or option not recognized."
                exit 2
            else
                command=$1
            fi
            shift
        ;;
        
    esac
done



#
# Validate (and publish) the path choosen
#
dir="$( getPathToDirectoryFor "$command" )"
if [ ! -d "$dir" ]; then
    badUsage "$MSG_FAILED Directory '$command' is not a valid directory."
    exit 2
fi

if [ -f "$HOME/.dbwebb-validate.config" ]; then . "$HOME/.dbwebb-validate.config"; fi
if [ -f "$DBWEBB_VALIDATE_CONFIG" ]; then . "$DBWEBB_VALIDATE_CONFIG"; fi

printf "Validating directory '%s'." "$dir"
validateHtmlCssJs "$dir" 
validatePython "$dir"
validateShell "$dir"
validatePHP "$dir"

if [[ $optPublish ]]; then
    if [ -z "$DBW_PUBLISH_BASEDIR" ]; then
        printf "\n$MSG_FAILED Missing basedir for publish, not supported.\n"
        exit 2
    fi
    
    if [ ! -d "$DBW_PUBLISH_BASEDIR" ]; then
        printf "\n$MSG_FAILED Basedir for publish is not a valid directory '%s'.\n" "$DBW_PUBLISH_BASEDIR"
        exit 2
    fi
    
    if [ -f "$DBW_COURSE_FILE" ]; then
        printf "\nTake subdir with coursedir.\n"
        printf $( dirname "$DBW_COURSE_DIR" )        
        printf "\n"
        a=$( dirname "$DBW_COURSE_DIR" )
        b=$( dirname "$DBW_COURSE_DIR" )
        target=${a#dir}
        printf "\n$target\n"
        target="$DBW_PUBLISH_BASEDIR"
    else
        target="$DBW_PUBLISH_BASEDIR/$( basename "$dir" )"
    fi
    
    # printf "\nPublishing to '%s'.\n" "$target"
    publish "$dir" "$target"
fi

assertResults


# TODO Validate for another user?
#THETARGET="$TARGET"
#if [ ! -z "$THEUSER" ]
#then
#    THETARGET=`eval echo "~$THEUSER/dbwebb-kurser/$COURSE"`
#fi
